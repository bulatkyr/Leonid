<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Леонид Межонов, задание 1</title>
	<style> ul {
	padding: 0; margin-left: 0; 
 	} 
 	p, ul {
 		font-size: 13px; font-family: times new roman;
 	}
 	table {
 		width: 300px;
 		border-collapse: collapse;
 	}
 	th {
 		text-align: left;
 		border-bottom: 1px solid black;
 		border-left: 1px solid black;
 	}
 	td {
    border-left: 1px solid black;
	}
	.lc {
    text-align: left;
    border-left: none;
   	}
</style>
</head>
<body>
<header>
	Блог компании Яндекс.
</header>
<article>
<h5>
ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ
</h5>
<p>
Если ваш сайт медленно грузится, вы рискуете тем, что люди не оценят ни то, <br>
какой он красивый, ни то, какой он удобный. Никому не понравится, когда все <br>
тормозит. Мы регулярно добавляем в Яндекс.Почту новую функциональность, <br>
иногда — исправляем ошибки, а это значит, у нас постоянно появляются новый код <br>
и новая логика. Всё это напрямую влияет на скорость работы интерфейса.
</p>
<p>
Что мы измеряем
</p> 
<p>
<ul> Этапы первой загрузки:
	<li style="list-style-position: inside;">подготовка;</li>
	<li style="list-style-position: inside;">загрузка статики (HTTP-запрос и парсинг);</li>
	<li style="list-style-position: inside;">исполнение модулей;</li>
	<li style="list-style-position: inside;">инициализация базовых объектов;</li>
	<li style="list-style-position: inside;">отрисовка.</li>
</ul>
</p>
<p>
	<ul> Этапы отрисовки любой страницы:
		<li style="list-style-position: inside;">подготовка к запросу на сервер;</li>
		<li style="list-style-position: inside;">запрос данных с сервера;</li>
		<li style="list-style-position: inside;">шаблонизация;</li>
		<li style="list-style-position: inside;">обновление <span translate="no">DOM</span>. </li>
	</ul>
</p>
<p>
	— <q>Ок, теперь у нас есть метрики, мы можем отправить их на сервер</q> - говорим мы <br>
	— <q>Что же дальше?</q> - вопрошаете вы <br>
	— <q>А давай построим график!</q> - отвечаем мы <br>
	— <q>А что будем считать?</q> - уточняете вы
</p>
<p>
Как вы знаете, медиана – это серединное, а не среднее значение в выборке. <br>
Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5. <br>
В общем случае медиана отлично показывает, сколько грузится средний пользователь.
</p>
<p>
В случае ускорения или замедления медиана, конечно, изменится. Но она не может <br>
рассказать, сколько пользователей ускорилось, а сколько замедлилось.
</p>
<p>
APDEX – метрика, которая сразу говорит: хорошо или плохо. Метрика <br>
работает очень просто. Мы выбираем временной интервал [0; t], такой, что если <br>
время показа страницы попало в него, то пользователь счастлив. Берем еще один <br>
интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница <br>
показана за это время, то пользователь в целом удовлетворен скоростью работы, <br>
но уже не настолько счастлив. И применяем формулу:
</p>
<p>
	Как мы измеряем
</p> 
<p>
Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять <br>
причину замедления: медленнее стал отвечать сервер либо слишком долго <br>
выполняется <span translate="no">JavaScript</span>. Выглядит это примерно так:
</p>
<p>
	<code>
		this.timings['look-ma-im-start'] = Date.now(); <br>
		this.timings['look-ma-finish'] = Date.now();
	</code>
</p>
<p>
C помощью <span translate="no">Date.now()</span> мы получаем текущее время. Все тайминги собираются и при <br>
отправке рассчитываются. На этапах разница между <span translate="no">“end”</span> и <span translate="no">“start”</span> не считается, <br>
а все вычисления производятся в конце:
</p>
<p>
	<code>
		var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];
	</code>
</p>
<p>
И на сервер прилетают подобные записи:
</p>
<p>
	<code>
		serverResponse=50&domUpdate=60
	</code>
</p>
<p>
Как мы ускоряем
</p>
<p>
Чтобы снизить время загрузки почты при выходе новых версий,
мы уже делаем следующее:
</p>
<p>
	<ul>
		<li style="list-style-position: inside;">включаем gzip;</li>
		<li style="list-style-position: inside;">выставляем заголовки кэширования;</li>
		<li style="list-style-position: inside;">фризим CSS, JS, шаблоны и картинки;</li>
		<li style="list-style-position: inside;">используем CDN;</li>
	</ul>
</p>
<p>
Мы подумали: <q>А что если хранить где-то старую версию файлов, а при выходе новой <br>
передавать только <span translate="no">diff</span> между ней и той, которая сохранена у пользователя?</q> <br>
В браузере же останется просто наложить патч на клиенте.
</p>
<p>
На самое деле эта идея не нова. Уже существуют стандарты для <span translate="no">HTTP</span> — например, <br>
<span translate="no">RFC 3229 «Delta encoding in HTTP»</span> и <span translate="no">«Google SDHC»</span>, — но по разным причинам они <br>
не получили должного распространения в браузерах и на серверах.
</p>
<p>
	<ul>
		Мы же решили сделать свой аналог на <span translate="no">JS</span>. Чтобы реализовать этот метод обновления, <br>
		начали искать реализации <span translate="no">diff</span> на <span translate="no">JS</span>. На популярных хостингах кода нашли <br>
		библиотеки:
		<li style="list-style-position: inside;"><code>VCDiff</code></li>
		<li style="list-style-position: inside;"><code>google-diff-patch-match</code></li>
	</ul>
</p>
<p>
Для окончательного выбора библиотеки нам нужно сравнить:
</p>
<p>
	<table cellspacing="0">
		<tr>
			<th class="lc"><font size="2", face="times new roman">Библиотека</font></th>
			<th><pre>IE 9</pre></th>
			<th><pre>Opera 12</pre></th>
		</tr>
		<tr>
			<td class="lc"><pre>vcdiff</pre></td>
			<td><pre>8</pre></td>
			<td><pre>5</pre></td>
		</tr>
		<tr>
			<td class="lc"><pre>googlediff</pre></td>
			<td><pre>1363</pre></td>
			<td><pre>76</pre></td>
		</tr>
	</table>
</p>
<p>
После того как мы определились с библиотекой для диффа, нужно определиться с тем, <br>
где и как хранить статику на клиенте.
</p>
<p>
Формат файла с патчами для проекта выглядит так:
</p>
<p>
	<code>
		<pre>
[
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    },
    {
        "k": "jane.css",
        "p": [patch],
        "s": 4554
    }
]
		</pre>
	</code>
</p>
<p>
То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У <br>
каждого объекта есть три свойства. k — названия ключа в <span translate="no">localStorage для этого</span> <br>
ресурса. p — патч для ресурса, который сгенерировал <span translate="no">vcdiff</span>. s — чексумма для <br>
ресурса актуальной версии, чтобы потом можно было проверить правильность <br>
наложения патча на клиенте. Чексумма вычисляется по алгоритму Флетчера.
</p>
<aside>
	<figure>
	<img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/bxX0F__8Eea3FxIaEbBXjA_012f5cdeec268cf6a3f89c5b926f75ab_1111.png?expiry=1630972800000&hmac=spVa3M7N7liF9i02KcyMLI-UfhA8DA6GLITxDyIoo7Y" alt="алгоритм Флетчера" width="400px"> <br>
	<figurecaption><font size="1", face="times new roman">Алгоритм Флетчера</font></figurecaption>
	</figure>
</aside>
<p>
Алгоритм Бройдена — Флетчера — Гольдфарба — Шанно (BFGS) <br>
— итерационный метод численной оптимизации, предназначенный для <br>
нахождения локального максимума/минимума нелинейного функционала <br>
без ограничений.
</p>
<p>
Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде: <br>
CRC16/32 - алгоритм нахождения контрольной суммы, предназначенный для проверки <br>
целостности данных <br>
md5 - 128-битный алгоритм хеширования. Предназначен для создания «отпечатков» <br>
или дайджестов сообщения произвольной длины и последующей проверки <br>
их подлинности.
</p>
<p>
Потому что он быстрый, компактный и легок в реализации.
</p>
<p>
	Итог
</p>
<p>
Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:
</p>
<p>
	<table cellspacing="0">
		<tr>
			<th class="lc"><font size="2", face="times new roman">Релиз</font></th>
			<th><font size="2", face="times new roman">С патчем</font></th>
			<th><font size="2", face="times new roman">Без патча</font></th>
		</tr>
		<tr>
			<td class="lc"><pre>7.7.20</pre></td>
			<td><pre>397</pre></td>
			<td><pre>174 549</pre></td>
		</tr>
		<tr>
			<td class="lc"><pre>7.7.21</pre></td>
			<td><pre>383</pre></td>
			<td><pre>53 996</pre></td>
		</tr>
		<tr>
			<td class="lc"><pre>7.7.22</pre></td>
			<td><pre>483</pre></td>
			<td><pre>3 995</pre></td>
		</tr>
	</table>
</p>
<p>
	<address>
Автор: <span itemprop="givenName">@doochik</span><br>
<span itemprop="JobTitle">C++ разработик</span><br>
Электронная почта: <a href="mailto:doochik@yandex-team.ru">doochik@yandex-team.ru</a><br>
Компания: <span itemprop="affiliation">Яндекс</span>
	</address>
</p>
<section>
	<h1><font face="times new roman">Комментарии</font></h1>
	<form>
	<textarea rows="5" cols="55" class="size-m" id="comment" placeholder="Введите комментарий"></textarea> <br>
	<button type="submit">Отправить</button>
	</form>
	<p>
- Mogaika <a href="mailto:mogaika@yandex-team.ru">mogaika@yandex-team.ru</a> 30 ноября 2014 в 17:05 <br>
<br>
  А можете привести сравнение, на сколько быстрее грузится lite версия? <br>
<br>
- JIguse (<a href="mailto:mrawesome@yandex.ru">mrawesome@yandex.ru</a> 29 ноября 2014 в 21:30 <br>
<br>
  Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми <br>
  подробностями о внутренней работе сервисов. <br>
<br>
- Brister <a href="mailto:brist89@yandex-team.ru">brist89@yandex-team.ru</a> 24 ноября 2014 в 13:13 <br>
<br>
  (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех). <br>
  Получается значение от нуля до единицы, которое, видимо, лучше всего показывает, <br>
  хорошо или плохо работает почта. <br>
<br>
  наверное все-таки от 0.5 до 1 <br>
<br>
- alexeimois <a href="mailto:test@yandex.ru">test@yandex.ru</a> 22 ноября 2014 в 17:35 <br>
<br>
  Мы измеряем скорость загрузки с помощью Яндекс.Метрики: <br>
  <a href="help.yandex.ru/metrika/reports/monitoring_timing.xml ">help.yandex.ru/metrika/reports/monitoring_timing.xml </a><br>
	</p>
</section>
</article>
<footer>
	<font size="2", face="times new roman">
	© Яндекс, <a href="mailto:help@yandex.ru">help@yandex.ru</a>, Хохрякова, 10
	</font>
</footer>
</body>
</html>	